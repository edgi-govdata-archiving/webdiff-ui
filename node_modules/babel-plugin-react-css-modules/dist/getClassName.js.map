{"version":3,"sources":["../src/getClassName.js"],"names":["isNamespacedStyleName","styleName","indexOf","getClassNameForNamespacedStyleName","styleModuleImportMap","styleNameParts","split","importName","moduleName","Error","styleNameValue","styleModuleImportMapKeys","Object","keys","filter","map","length","styleModuleMap","join"],"mappings":";;;;;;;AAOA,MAAMA,wBAAyBC,SAAD,IAAgC;AAC5D,SAAOA,UAAUC,OAAV,CAAkB,GAAlB,MAA2B,CAAC,CAAnC;AACD,CAFD;;AAIA,MAAMC,qCAAqC,CAACF,SAAD,EAAoBG,oBAApB,KAA+E;AACxH;AACA;AACA;AACA,QAAMC,iBAAiBJ,UAAUK,KAAV,CAAgB,GAAhB,CAAvB;AACA,QAAMC,aAAaF,eAAe,CAAf,CAAnB;AACA,QAAMG,aAAaH,eAAe,CAAf,CAAnB;;AAEA,MAAI,CAACG,UAAL,EAAiB;AACf,UAAM,IAAIC,KAAJ,CAAU,qBAAV,CAAN;AACD;;AAED,MAAI,CAACL,qBAAqBG,UAArB,CAAL,EAAuC;AACrC,UAAM,IAAIE,KAAJ,CAAU,mCAAV,CAAN;AACD;;AAED,MAAI,CAACL,qBAAqBG,UAArB,EAAiCC,UAAjC,CAAL,EAAmD;AACjD,UAAM,IAAIC,KAAJ,CAAU,4BAAV,CAAN;AACD;;AAED,SAAOL,qBAAqBG,UAArB,EAAiCC,UAAjC,CAAP;AACD,CArBD;;kBAuBe,CAACE,cAAD,EAAyBN,oBAAzB,KAAoF;AACjG,QAAMO,2BAA2BC,OAAOC,IAAP,CAAYT,oBAAZ,CAAjC;;AAEA,SAAOM,eACJJ,KADI,CACE,GADF,EAEJQ,MAFI,CAEIb,SAAD,IAAe;AACrB,WAAOA,SAAP;AACD,GAJI,EAKJc,GALI,CAKCd,SAAD,IAAe;AAClB,QAAID,sBAAsBC,SAAtB,CAAJ,EAAsC;AACpC,aAAOE,mCAAmCF,SAAnC,EAA8CG,oBAA9C,CAAP;AACD;;AAED,QAAIO,yBAAyBK,MAAzB,KAAoC,CAAxC,EAA2C;AACzC,YAAM,IAAIP,KAAJ,CAAU,2EAAV,CAAN;AACD;;AAED,QAAIE,yBAAyBK,MAAzB,GAAkC,CAAtC,EAAyC;AACvC,YAAM,IAAIP,KAAJ,CAAU,uEAAV,CAAN;AACD;;AAED,UAAMQ,iBAAqCb,qBAAqBO,yBAAyB,CAAzB,CAArB,CAA3C;;AAEA,QAAI,CAACM,eAAehB,SAAf,CAAL,EAAgC;AAC9B,YAAM,IAAIQ,KAAJ,CAAU,gCAAV,CAAN;AACD;;AAED,WAAOQ,eAAehB,SAAf,CAAP;AACD,GAzBI,EA0BJiB,IA1BI,CA0BC,GA1BD,CAAP;AA2BD,C","file":"getClassName.js","sourcesContent":["// @flow\n\nimport type {\n  StyleModuleMapType,\n  StyleModuleImportMapType\n} from './types';\n\nconst isNamespacedStyleName = (styleName: string): boolean => {\n  return styleName.indexOf('.') !== -1;\n};\n\nconst getClassNameForNamespacedStyleName = (styleName: string, styleModuleImportMap: StyleModuleImportMapType): string => {\n  // Note:\n  // Do not use the desctructing syntax with Babel.\n  // Desctructing adds _slicedToArray helper.\n  const styleNameParts = styleName.split('.');\n  const importName = styleNameParts[0];\n  const moduleName = styleNameParts[1];\n\n  if (!moduleName) {\n    throw new Error('Invalid style name.');\n  }\n\n  if (!styleModuleImportMap[importName]) {\n    throw new Error('CSS module import does not exist.');\n  }\n\n  if (!styleModuleImportMap[importName][moduleName]) {\n    throw new Error('CSS module does not exist.');\n  }\n\n  return styleModuleImportMap[importName][moduleName];\n};\n\nexport default (styleNameValue: string, styleModuleImportMap: StyleModuleImportMapType): string => {\n  const styleModuleImportMapKeys = Object.keys(styleModuleImportMap);\n\n  return styleNameValue\n    .split(' ')\n    .filter((styleName) => {\n      return styleName;\n    })\n    .map((styleName) => {\n      if (isNamespacedStyleName(styleName)) {\n        return getClassNameForNamespacedStyleName(styleName, styleModuleImportMap);\n      }\n\n      if (styleModuleImportMapKeys.length === 0) {\n        throw new Error('Cannot use styleName attribute without importing at least one stylesheet.');\n      }\n\n      if (styleModuleImportMapKeys.length > 1) {\n        throw new Error('Cannot use anonymous style name with more than one stylesheet import.');\n      }\n\n      const styleModuleMap: StyleModuleMapType = styleModuleImportMap[styleModuleImportMapKeys[0]];\n\n      if (!styleModuleMap[styleName]) {\n        throw new Error('CSS module cannot be resolved.');\n      }\n\n      return styleModuleMap[styleName];\n    })\n    .join(' ');\n};\n"]}